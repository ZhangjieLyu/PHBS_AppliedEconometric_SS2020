import numpy as np
import pandas as pd
import collections
import statsmodels.api as sm
from numpy.linalg import inv
import itertools
from ConstructFactors import ConstructFactors

class CreateFactorTable(ConstructFactors):
    def __init__(self, data):
        super().__init__(data)
        self.dataFrame = pd.DataFrame()
        
    def gen_DataFrame(self):
        self.dataFrame = pd.DataFrame(index = self.data.index)
        
    def buildDataFrame(self, colNames):
        for col in colNames:
            self.dataFrame[col] = self.data[col]
            
    def get_DataFrame(self):
        return self.dataFrame
    
    def set_DataFrame(self, newDf):
        self.dataFrame = newDf
        
    def getMethod(self):
        computeMethods = [methodName for methodName in dir(CreateFactorTable) 
                          if methodName.split("_")[0] == "compute"]
        colNames = [methodName.split("_")[-1] for methodName in dir(CreateFactorTable) 
                   if methodName.split("_")[0] == "compute"]
        return {colName:computeMethod for colName,computeMethod 
                in zip(colNames, computeMethods)}
        
    def applyMethod(self):
        if len(self.getMethod()) == 0:
            print("empty methods!")
            return
        
        methodDict = self.getMethod()
        
        newDf = self.dataFrame
        for colName in methodDict:
            newColVals = getattr(CreateFactorTable, methodDict[colName])(self)
            newDf[colName] = newColVals
        
        # return modified dataframe
        self.set_DataFrame(newDf)
            
        return newDf
    
    def labelBySortColumn(self, colName, refColName = ["SID","Trading_Date"], num_split = 3):
        """
        cross-sectional label
        
        Parameters
        ----------
        colName: str, column name of the column desired to be sorted
        refColName: list[str], [stockID, date]
        num_split: number of splits, int>0
        
        Returns
        -------
        rtype:in self.DataFrame, a column named "labelled_YourColumnName", labelled by 1,...,#splits,
        1 means the lowest percent(lowest value), #splits means the toppest percent(highest value)
        """       
        try:
            SID = refColName[0]
            Trading_Date = refColName[1]
        except:
            print("please make sure refColName = [SID, Trading_Date] is in your dataframe, use obj.get_DataFrame() to check!")
        
        dataSub = pd.DataFrame(self.get_DataFrame()[[SID, Trading_Date, colName]])
        newColVal = dataSub.groupby(Trading_Date).apply(lambda x:np.ceil(x[colName].rank()/(len(x[~x.isnull().any(axis=1)])/num_split))).reset_index().sort_values(by = "level_1")[colName].values
        
        self.get_DataFrame()["labelled_"+colName] = newColVal
        
    def utils_pandaSelection(self, dataFrame, conditionDict):
        """

        Parameters
        ----------
        dataFrame : pd.DataFrame
            DESCRIPTION.
        conditionDict: dict {"colName":[1,2,3]}

        Returns
        -------
        pandas DataFrame.

        """
        colNames = [col for col in conditionDict.keys()]
        colItems = [item for item in conditionDict.values()]
        selection_logic = np.logical_and(dataFrame[colNames[0]].isin(colItems[0]),
                                         dataFrame[colNames[1]].isin(colItems[1]))
        return(pd.DataFrame(dataFrame[selection_logic]))
        
            
    def constructPortfolioBySortedColumns(self, splitStructure, returnColName, dateColName = "Trading_Month",weight = "Total_Market_Value", weightReferenceCol = "Tot_MV"):
        """
        construct a dataframe from sorted columns generated by labelBySortColumn

        Parameters
        ----------
        splitStructure : dict(dict) of length 2
            e.g. {"Tot_MV":{"S":[10,20,30,40,50],"B":[60,70,80,90,100]}, "EP":{"G":[10,20,30],"M":[40,50,60,70],"V":[80,90,100]}}, must be int, the later one must not be no longer than the previous one
        returnColName : str
            column name storing asset's return.
        dateColName: str
            column name storing asset's trading dates, The default is "Trading_Date"
        weight : str, optional
            in future version, "Total_Market_Value" or "Floating_Market_Value". The default is "Total_Market_Value".(the only available one currently)

        Returns
        -------
        a pandas dataframe object.

        """
        #construct column names
        dictKeys = [key for key in splitStructure.keys()]
        splitCond1 = [e for e in splitStructure[dictKeys[0]].keys()]
        # splitThres1 = [e/10-1 for e in splitStructure[dictKeys[0]].values()]
        splitCond2 = [e for e in splitStructure[dictKeys[1]].keys()]
        # splitThres2 = [e/10-1 for e in splitStructure[dictKeys[0]].values()]
        
        allCombinationsTuple = [list(zip(each_permutation, splitCond1)) for each_permutation in itertools.permutations(splitCond2, len(splitCond1))]
        allCombinationsList = set(list(itertools.chain.from_iterable(allCombinationsTuple)))
        newColNames = [col[1]+"/"+col[0] for col in allCombinationsList]
        
        #total market value weighted portfolio construction by date
        portfolioReturnList = []
        newDataIndex = np.unique(self.get_DataFrame()[dateColName].values)

        #add a new weight column, in case of collision
        self.get_DataFrame()["weightBy_"+weightReferenceCol] = self.get_DataFrame()[weightReferenceCol]
        
        #call labelled colns
        self.labelBySortColumn(dictKeys[0], num_split = 10)
        self.labelBySortColumn(dictKeys[1], num_split = 10)
        
        for date in newDataIndex:
            # select by date
            data_byDate = pd.DataFrame(self.get_DataFrame()[self.get_DataFrame()[dateColName] == date][[dateColName, 
                                                                                                        returnColName,
                                                                                                        "weightBy_"+weightReferenceCol,
                                                                                                        dictKeys[0], 
                                                                                                        "labelled_"+dictKeys[0],
                                                                                                        dictKeys[1],
                                                                                                        "labelled_"+dictKeys[1]]])
            #generate selection condition
            comb_portfolioRet = []
            for comb in newColNames:
                keyFromDict1 = comb.split("/")[0]
                keyFromDict2 = comb.split("/")[1]
                cond1 = [x/10 - 1 for x in splitStructure[dictKeys[0]][keyFromDict1]]
                cond2 = [x/10 - 1 for x in splitStructure[dictKeys[1]][keyFromDict2]]
                conditionDict = {"labelled_"+dictKeys[0]:cond1, "labelled_"+dictKeys[1]:cond2}
                data2Compute = self.utils_pandaSelection(data_byDate, conditionDict)
                
                # transform tot market value to weight
                try:
                    data2Compute["weightBy_"+weightReferenceCol] = data2Compute["weightBy_"+weightReferenceCol]/data2Compute["weightBy_"+weightReferenceCol].sum()
                    newVal = np.nansum(data2Compute["weightBy_"+weightReferenceCol].values*data2Compute[returnColName].values)
                except:
                    print("error in computation:"+date+" "+comb)
                    newVal = np.nan
                
                comb_portfolioRet.append(newVal)
                
            portfolioReturnList.append(comb_portfolioRet)
            
        return(pd.DataFrame(data=portfolioReturnList, columns=newColNames, index = newDataIndex))